# 데이터베이스 CS 스터디 10주차

데이터베이스 10주차 스터디입니다.

한빛아카데미의 `MySQL로 배우는 데이터베이스 개론과 실습` 책을 기반으로 작성했습니다.

작성자 : YMGYM(안민준)

## 개요

데이터베이스가 작업할 때 작업 중간에 오류 등으로 인해 작업이 중단되는 경우, 작업이 일부만 완료된 상태가 아니라, 처음부터 없던 일로 되어야 합니다.

만약 데이터의 일부만 바뀌어 있으면 큰 문제가 생기게 될 것입니다.

데이터베이스는 이렇게 작업(거래)를 트랜잭션으로 관리합니다. 이번 주차에서는 트랜잭션에 대해서 알아 보도록 하겠습니다.

## 트랜잭션(Transaction)

트랜잭션은 DBMS 에서 데이터를 다루는 논리적인 작업의 단위입니다.

트랜잭션을 정의하는 이유는 아래와 같습니다

- 장애 발생 시 데이터를 복구하기 위해

- 동시에 같은 데이터를 다루는 상황에서 작업을 서로 분리하기 위해

트랜잭션은 작업을 수행할 때 전체가 수행되거나 또는 전혀 수행되지 않아야 한다는 원칙이 있으며 이를 all or nothing 원칙이라고 합니다.



### 트랜잭션의 처리 방법

트랜잭션은 SQL 문에서 아래 처럼 표시됩니다.

```
START TRANSACTION
    A계좌에서 10,000원을 인출 (UPDATE)
    B계좌에서 10,000원을 입금 (UPDATE)
COMMIT
```



이 때, 데이터베이스는 주로 데이터를 하드디스크에 저장해 두었다가 주기억장치 버퍼로 값을 불러와서 작업 합니다.

따라서 위 SQL 문의 작업 순서는 아래 작업들이 포함됩니다.

1. A계좌의 값을 하드디스크에서 주기억장치 버퍼로 읽어 옴

2. B계좌의 값을 하드디스크에서 주기억장치 버퍼로 읽어 옴

3. A계좌에서 10,000원을 인출한 값을 저장함

4. B계좌에서 10,000원을 입금한 값을 저장함

5. A계좌의 값을 주기억장치 버퍼에서 하드디스크에 저장함

6. B계좌의 값을 주기억장치 버퍼에서 하드디스크에 저장함



이 때 DBMS는 4번 과정까지 완료하고 COMMIT(사용자에게 트랜잭션의 종료를 알림)을 수행합니다.

이후 하드디스크에 데이터를 기록하는 과정을 맡아서 수행하게 됩니다. 5,6번 과정은 하드디스크에 데이터를 기록하는 행위로 시간이 오래 걸리기 때문입니다.

![Database] 트랜잭션의 정의와 수행진행, 트랜잭션의 성질 ACID를 알아보자](https://t1.daumcdn.net/cfile/tistory/9977E54B5B36AEF510)

출처 : [[Database] 트랜잭션의 정의와 수행진행, 트랜잭션의 성질 ACID를 알아보자](https://deftkang.tistory.com/m/53)



## 트랜잭션의 성질

트랜잭션은 아래 네 가지 성질을 갖습니다.

- 원자성(Atomicity) : 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.

- 일관성(Consistency) : 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.

- 고립성(Isolation) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다.

- 지속성(Durability) : 수행을 성공적으로 완료한 트랜잭션은 변경된 데이터를 영구히 저장해야 한다.

이와 같은 성질은 영문 첫 글자를 따서 ACID 성질이라고 부릅니다.



### 원자성 (Atomicity)

트랜잭션은 쪼개지지 않는 하나의 단위의 작업 이어야 합니다.

트랜잭션이 일부만 수행되서는 안 된다는 의미입니다.

따라서 DBMS는 트랜잭션 중간에 작업이 잘못되면 회복 알고리즘을 사용하여 변경한 내용을 취소합니다. (ROLLBACK 으로 자의적인 트랜잭션 취소도 가능)

트랜잭션이 긴 경우 SAVEPOINT 를 만들어서 일일부까지만 돌아갈 수 있습니다.



### 일관성 (Consistency)

트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효한 상태여야 한다는 뜻 입니다.

'유효한 상태'의 의미는 CREATE 나 ALTER 등으로 테이블을 생성할 때 설정한 무결성 제약조건을 만족함을 의미합니다.

이에 더해 상식적(처리 로직상 발생하는 내용)으로 발생하는 것을 의미하는 암시적 일관성 제약 조건도 있습니다.

![](https://thebook.io/img/006977/204_2.jpg)

출처 : [모두의 SQL: 일관성](https://thebook.io/006977/ch09/02/01/02/)

위처럼 계좌 이체의 트랜잭션에서 트랜잭션 과정에서는 두 계좌의 잔액 합이 다를 수 있지만, 트랜잭션이 완료된 경우에는 잔액 합이 일정해야 합니다.



### 고립성 (Isolation)

고립성은 트랜잭션끼리 같은 데이터를 가지고 충돌하지 않도록 해야 한다는 것을 말합니다.

이 과정을 동시성 제어라고 합니다. (이후 자세히 나옵니다)



### 지속성 (Durability)

트랜잭션이 정상적으로 완료, 부분완료한 데이터는 반드시 데이터베이스에 기록되어 이후에도 계속 기록되어 있어야 합니다.

DBMS는 트랜잭션 작업 내용을 로그에 기록한 뒤, 시스템에 문제가 발생하면 로그 파일을 이용하여 복구를 수행합니다.

![트랜잭션 상태전이도.png](https://itwiki.kr/images/1/1e/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84.png)

출처 : [트랜잭션 - IT위키](https://itwiki.kr/w/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)

- 부분 완료 : 작업은 완료했지만, 변경 사항이 데이터베이스에 기록되어있는지 확실하지 않은 상태. 이 과정에서 오류가 발생한 경우에도 Failed 상태가 됨

- 실패 : DBMS는 트랜잭션이 수행한 작업을 모두 원상복구 시킴



### 트랜잭션과 DBMS

![](https://velog.velcdn.com/images%2Fyohanblessyou%2Fpost%2F2243c318-5f26-4943-af1c-8920cb0b24ec%2Fimage.png)

출처 : https://velog.io/@yohanblessyou/CS-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-5.-Normalization-Indexing-Transaction

DBMS는 트랜잭션의 성질을 유지하기 위해 기능을 사용합니다.



## 동시성 제어

DBMS는 최대한 동시에 많은 작업을 수행하는 것이 이득입니다.

하지만 무턱대고 같은 데이터에 접근하는 트랜잭션을 동시에 실행시키면 일관성 등의 문제가 발생할 수 있습니다. 

이를 제어하는 과정을 '동시성 제어 (Concurrency control)'라고 합니다.



### 갱신 손실 문제 (lost update)

갱신 송신 문제는 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생합니다.

![](https://velog.velcdn.com/images/songyw0517/post/ca748366-bf02-4c7d-94a2-23c62fea6243/image.png)

출처 : [scof.log - 트랜잭션](https://velog.io/@songyw0517/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)

- T1 이 작업을 위해 값을 읽어 버퍼에 올림

- T2도 작업을 위해 값을 읽어 버퍼에 올림

- T1이 작업을 마치고 900 값을 씀

- T2가 작업을 마치고 900을 무시하고 1100을 덮어 씀



### 락(lock)

갱신 손실 문제를 해결하기 위해서는 lock을 사용합니다.

락은 자신이 데이터를 수정 중이라는 사실을 알리는 일종의 잠금장치의 개념입니다.

![](https://velog.velcdn.com/images/songyw0517/post/43b29c46-e528-4936-947e-a849a835629a/image.png)

출처 : [scof.log - 트랜잭션](https://velog.io/@songyw0517/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)



락을 이용하면 T2 는 자신의 데이터를 읽지 못하고 T1이 UNLOCK할 때까지 기다려야 합니다.



### 락의 유형

락은 다른 트랜잭션을 대기로 만드는 일이고, 결국 응답 시간에 영향을 주게 됩니다. 따라서 가능한 최소화하는 것이 바람직합니다.

트랜잭션에는 1. 데이터를 읽기만 함, 2. 데이터를 읽고 쓰기, 3. 데이터를 쓰기만 함 이 있는데, 1번과 같은 경우는 어느 정도 접근을 허용해도 문제가 없습니다.

이를 반영하여 락을 두 종류로 만드는 방법이 있습니다.

- 공유락 (LS, shared lock) : 트랜잭션이 읽기를 할 때 사용함

- 배타락 (LX, exclusive lock) : 트랜잭션이 읽기/쓰기를 함

이와 같이 두 가지 종류의 락을 두고 다음과 같이 사용합니다.

- 데이터에 락이 걸려 있지 않으면, 트랜잭션은 접근 후 락을 걸 수 있다.

- 데이터가 LS(X) 이면, LS의 요청은 허용하고 LX는 허용하지 않는다.

- 데이터가 LX이면, LS, LX 모두 허용하지 않는다



### 2단계 락킹

위와 같이 락킹을 사용해도, 락을 풀고 다시 락을 거는 시점의 차이 때문에 데이터 일관성에 문제가 생기는 경우도 존재합니다.

T1의 경우는 A에서 100을 빼서 B에 더하는 작업, T2는 A,B의 값을 1.1배 하는 작업입니다.

![](https://velog.velcdn.com/images/songyw0517/post/bdbf1f32-3c67-4c32-9f31-0eba39d0b9c9/image.png)

출처 : [scof.log - 트랜잭션](https://velog.io/@songyw0517/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)

이 경우 데이터 A를 처리하고 B를 처리하는 과정 사이에 T2가 끼어 들어 값을 변조하고, 그 결과 암시적인 일관성 제약 조건을 깨트리게 됩니다



이를 해결하기 위해서 2단계 락킹을 사용합니다.

2단계 락킹은 락을 걸고 해제하는 시점을 2개 단계로 나누어서 진행합니다.

- 확장 단계 (Expanding Phase) : 트랜잭션이 필요한 락을 획득하는 단계. 이미 획득한 락을 해제하지 않음

- 수축 단계 (Shrinking Phase) : 트랜잭션이 락을 해제하는 단계. 새로운 락을 획득하지 않음

![](https://velog.velcdn.com/images/songyw0517/post/6184ce68-e562-4ec5-9e40-3c1106784419/image.png)

출처 : [scof.log - 트랜잭션](https://velog.io/@songyw0517/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)

T1이 작업을 마무리하고 언락 할 때까지는 확장 단계로 하여 LX(B)전에 UN(A)를 수행하지 않습니다.

이 경우 일관성 제약조건을 지킬 수 있습니다.



### 데드락

이와 같이 2단계 락킹을 사용하면 일관성을 지킬 수 있습니다.

하지만 아래와 같은 상황에서 문제가 발생합니다.

- T1이 A에 대해 락을 걸고 B의 언락을 기다림

- T2가 B에 대해 락을 걸고 A의 언락을 기다림

이와 같은 상황에서는 서로가 서로의 언락을 기다리며 무한 대기에 빠질 수 있습니다. 이와 같은 상황을 데드락(deadlock) 혹은 교착상태 라고 합니다.



일반적으로 데드락이 발생하면 DBMS는 T1, T2의 작업 하나를 강제로 중지하고, 나머지 트랜잭션을 실행합니다. 이 때 중지되는 트랜잭션도 원자성을 만족하여 원래 상태로 돌아가야 합니다.



# 참고문서

- [[데이터베이스] 트랜잭션의 ACID 성질 - 하나몬](https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/)

- [scof.log - 트랜잭션](https://velog.io/@songyw0517/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)
