## 프로세스와 IPC

### 프로세스를 구성하는 요소

![프로세스 구성 요소](https://user-images.githubusercontent.com/32683894/87295971-02476180-c541-11ea-8530-9a23e640c982.jpg)

- Code 영역 - 실행파일을 구성하는 명령어들이 올라가는 메모리 영역
- Data영역 - 전역변수, static변수
- Stack영역 - 지역변수, 전달인자 정보
- Heap영역 - 동적 할당



### 프로세스의 스케줄링과 상태변화

스케줄링 - 프로세스의 CPU 할당순서 및 방법을 결정짓는 일

스케줄러 - 스케줄링 알고리즘을 적용해서 실제로 프로세스를 관리하는 운영체제 요소(소프트웨어)

#### 상태변화

![프로세스 상태전이도.png](https://itwiki.kr/images/thumb/d/da/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84.png/500px-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C%EC%A0%84%EC%9D%B4%EB%8F%84.png)

1. 생성 -> Ready

   프로세스가 생성되면 먼저 Ready상태가 됨

2. Ready->Run

   Ready상태에 있는 프로세스들은 스케줄러에 의해서 관리되는 프로세스들.

   스케줄러는 Ready상태에 있는 프로세스 중 하나를 선택해서 CPU에 의해 실행될 수 있도록 함

3. Run->Ready

   프로세스들은 생성 시 중요도에 따라 우선순위가 매겨짐.

   따라서, 우선순위가 밀리가 되면 Running중에 Ready상태로 이전하게 됨

4. Running->Blocked

   실행 중에 잇는 프로세스가 실행을 멈추는 상태로 들어감. 일반적으로 I/O처리 중에 발생

5. Blocked->Ready

   Blocked상태는 스케줄러에 의해서 선택될 수 없는 상태

   따라서 I/O가 완료되면 Ready로 돌아가야 함



## 컨텍스트 스위칭

![img](https://blog.kakaocdn.net/dn/1beHI/btqyg8EcSGW/QRL9cBs19xJ1yRvrBwi8y0/img.png)

- CPU 내에 존재하는 레지스터들은 현재 실행 중에 있는 프로세스 관련 데이터들로 채워짐
- 그러나, 실행중인 프로세스가 변경되면 CPU내에 존재하는 레지스터의 값이 변경되어 현재 레지스터들이 지니고 있는 데이터들을 메모리에 저장하고 Ready상태에 있던 프로세스의 이전 레지스터값을 메모리에서 불러오는 과정
- 레지스터 개수가 많은 시스템일수록, 프로세스별로 관리되어야 할 데이터 종류가 많을수록 빈번하게 발생



## 커널 오브젝트와 오브젝트 핸들

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Kernel_Layout.svg/200px-Kernel_Layout.svg.png)

커널 - 컴퓨터를 운영하는 데 있어서 중심이 되는 운영체제 핵심 부분

### 커널 오브젝트

- 커널에서 관리하는 중요한 정보를 담아둔 데이터 블록
- Windows운영체제가 프로세스, 스레드 혹은 파일과 같은 리소스들을 원할하게 관리하기 위해 필요한 정보를 저장해야 하는데 이 때 데이터를 저장하는 메모리 블록을 가리켜 커널 오브젝트라고 함
- Ex) 프로세스 커널 오브젝트 -> 프로세스 관리

### 오브젝트 핸들을 이용한 커널 오브젝트 조작

- 프로그래머가 직접 커널 오브젝트를 조작하는 것은 불가능
- 핸들 - 커널 오브젝트에 할당되는 숫자
- Windows는 커널 오브젝트를 생성할 때마다 핸들을 하나씩 부여함
- HANDLE <-> 커널 오브젝트 <-> 리소스의 구조
- 커널 오브젝트 -> 운영체제에 종속적
- 핸들 -> 프로세스에 종속적
- CloseHandle - 프로세스가 소멸된다고 커널 오브젝트가 소멸되지 않음.(운영체제가 정하기 때문)
- 자식 프로세스의 종료코드는 자식 프로세스의 커널 오브젝트에 저장됨

#### 프로세스 핸들과 ID의 차이

- 핸들 - 프로세스의 커널 오브젝트를 구분하기 위한 것
- ID - 커널 오브젝트가 아니라 프로세스 자체를 구분짓기 위한 것



### 커널 오브젝트와 Usage Count

- 자식 프로세스의 종료코드는 자식 프로세스의 커널 오브젝트에 저장됨. 따라서, 자식 프로세스가 종료될 때 커널 오브젝트도 동시에 소멸된다면 부모 프로세스는 종료코드를 얻을 수 없음. -> 프로세스가 종료된다고 커널 오브젝트까지 동시에 소멸시키지는 않음
- 커널 오브젝트 소멸 시점 - 커널 오브젝트를 참조하는 대상이 하나도 없을 때 소멸시키는 것이 이상적. Windows가 이렇게 작동.
- Usage Count - 커널 오브젝트를 참조하는 대상의 개수
- Usage Count가 0이 되면 운영체제는 해당 커널 오브젝트를 소멸시킴.
- CloseHandle -> 핸들을 반환하면서 커널 오브젝트의 Usage Count를 1 감소시킴.(커널 오브젝트 삭제가 아님!!), 주로 부모 프로세스에서 실행!