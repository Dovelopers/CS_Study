## 컴퓨터 하드웨어의 구성

### CPU

![img](https://t1.daumcdn.net/cfile/tistory/99E975335A1D3AE735)

- ALU(연산 장치) - CPU에서 실제 연산을 담당. 산술연산과 논리연산을 수행
- 컨트롤 유닛(제어 장치) - 명령어를 Decode하고 결과에 따라 적절한 신호를 CPU의 다른 블록에 보냄
- 레지스터 - 임시적으로 데이터를 저장하기 위한 공간. 버스 인터페이스를 통해 RAM으로부터 처리를 기다리는 데이터를 받아옴
- 버스 인터페이스 - 레지스터에서 데이터를 I/O버스로 보내거나 받음

### 메인 메모리

컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역

### 클럭

컴퓨터에서 각 부품에서 발생하는 신호는 제각각의 처리속도를 갖고있기 때문에 이벤트 형식으로 신호를 I/O버스를 통해 CPU로 보내면 신호가 섞이거나 처리하지 못할 가능성이 있음 -> 동기화를 위해 클럭신호를 사용함

## 프로그램의 생성 과정

1. 전처리기에 의한 치환작업 - #으로 시작하는 지시자의 지시에 따라 소스코드를 적절히 변경
2. 컴파일러에 의한 번역 - 소스코드 -> 어셈블리 코드
3. 어셈블러에 의한 바이너리 코드 생성
4. 링커에 의한 연결과 결합
5. 실행파일 생성

## 실행과정

1. 실행파일 실행
2. 메모리에 번역된 명령어들이 올라감
3. I/O버스를 통해 CPU의 레지스터에 명령어들이 이동(Fetch)
4. 컨트롤유닛에서 Decode(Decode)
5. 실제 ALU에서 명령어 실행(Execution)

## 64비트와 32비트의 차이

한 번에 송수신할 수 있는 데이터의 크기와 한 번에 처리할 수 있는 데이터 크기를 기준으로 32비트와 64비트를 나눔

64비트는 주소를 표현하는데 64비트를 사용하기 때문에 프로그래머가 표현할 수 있는 값의 범위를 넓힘

## 레지스터 디자인 방법

1. 레지스터를 몇 비트로 구성할 것인가
2. 레지스터를 몇 개 정도로 구성할 것인가
3. 레지스터 각각을 무슨 용도로 사용할 것인가

Ex) 레지스터 16비트, 8개일 경우

![스크린샷 2022-07-02 오후 8.55.51](/Users/oh/Library/Application Support/typora-user-images/스크린샷 2022-07-02 오후 8.55.51.png)

### 명령어 디자인

- CPU에 따라서 명령어가 달라짐 -> 레지스터 구조에 따라 명령어 구조가 바뀜
- Ex에서는 16비트 레지스터기 때문에 명령어도 16비트로 구성

![스크린샷 2022-07-02 오후 9.08.07](/Users/oh/Library/Application Support/typora-user-images/스크린샷 2022-07-02 오후 9.08.07.png)

위의 경우엔 "레지스터 r1의 값과 7을 더해서 r2에 저장한다"라는 명령어가 됨.

첫번째 피연산자 위치에는 레지스터 이름이 와야함

### 명령어 처리 과정

1. Assemble - Add, r2, r1, 7의 데이터 입력
2. 메모리 로드 - 명령어에 위 Add, r2, r1, 7에 해당하는 이진값을 넣음
3. Fetch - 해당 명령어를 메인 메모리에서 레지스터로 이동시킴(instruction register)
4. Decode - 컨트롤 유닛에서 해석
5. Execution - ALU에서 처리